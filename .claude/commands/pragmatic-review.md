---
name: pragmatic-review
description:
  'Interactive pragmatic code review focusing on YAGNI and KISS principles'
version: 1.0.0
argument-hint:
  '[--auto] [--ci] [--deep (6-pass)] [--branch branch-name] [--base base-branch]'
allowed-tools:
  [
    Read,
    Grep,
    Glob,
    Bash(test:*),
    Bash(git:*),
    Bash(echo:*),
    Bash(head:*),
    Bash(wc:*),
    Bash(tr:*),
  ]
---

# 实用代码审查：YAGNI & KISS 重点

你将执行交互式代码审查，重点关注 **YAGNI**（你不会需要它）和 **KISS**（保持简单，愚蠢）原则。

## 审查模式

**默认模式**：快速 YAGNI/KISS 重点审查

- 扫描过度工程、未使用的抽象、不必要的复杂性
- 快速安全和性能检查（OWASP 基础、明显的 N+1 查询）
- 自我反思以用证据验证发现

**深度模式**（`--deep` 标志）：多通道综合审查

- 通道 1：安全（OWASP 前 10、输入验证、身份验证问题）
- 通道 2：架构（SOLID 原则、关注点分离）
- 通道 3：逻辑（边缘情况、错误处理、正确性）
- 通道 4：性能（算法复杂度、资源泄漏）
- 通道 5：YAGNI/KISS（过度工程、不必要的抽象）
- 通道 6：可维护性（可读性、测试、文档）
- 所有通道后的自我反思

在以下情况下使用 `--deep`：

- 安全关键更改（身份验证、支付、数据处理）
- 核心架构修改
- 具有许多边缘情况的复杂逻辑更改
- 性能敏感代码路径

在以下情况下使用默认模式：

- 功能添加
- 错误修复
- 重构
- 文档更改

**CI 模式**（`--ci` 标志）：GitHub Actions 的非交互模式

- 跳过所有交互式提示
- 自动选择：所有分支更改与基础分支
- 如果可用则使用 `$GITHUB_BASE_REF` 环境变量
- 一次性将所有发现输出为 markdown（摘要视图）

## 步骤 1：确定审查范围

### 检查当前 Git 状态

首先，通过运行验证我们是否在 git 仓库中：

- `test -d .git` 检查 .git 目录是否存在

如果不在 git 仓库中，请用户手动指定要审查的文件。

如果在 git 仓库中，收集信息：

#### 当前分支：
运行：`git rev-parse --abbrev-ref HEAD`

#### 默认分支检测：
1. 尝试：`git rev-parse --verify main`
2. 如果失败，尝试：`git rev-parse --verify master`
3. 如果失败，尝试：`git rev-parse --verify develop`

如果用户在参数中指定了 `--base [branch]`，则使用该分支。

#### 工作目录状态：
运行：`git status --short | head -20`

### 向用户展示选项

**如果存在 `--ci` 标志**：跳过所有交互式提示并自动选择
选项 2：审查当前分支与基础分支的所有更改。

除非存在 `--auto` 或 `--ci` 标志，否则询问用户：

```
📋 代码审查范围选择
════════════════════════════════

你想审查什么？

1️⃣  当前未提交的更改
2️⃣  当前分支上的所有更改（与 [检测到的默认分支] 相比）
3️⃣  特定文件或目录
4️⃣  最近 N 次提交
5️⃣  仅暂存的更改

请输入你的选择（1-5）：
```

## 步骤 2：YAGNI/KISS 分析框架

对于每个识别的文件，分析这些模式：

### YAGNI 检测模式

1. **未使用的抽象**
   - 具有单个实现的接口/协议
   - 具有一个具体子类的抽象基类
   - 始终相同的泛型类型

2. **过早的灵活性**
   - 从不变化的配置
   - 没有插件的插件系统
   - 始终开/关的功能标志

3. **过度工程指标**
   - 简单对象的工厂类
   - 具有 2-3 个字段的对象的 Builder 模式
   - 具有单个监听器的事件系统

4. **投机性代码**
   - "TODO：可能需要这个"注释
   - "以防万一"注释掉的代码
   - 无法访问的代码路径
   - 从未被调用的方法

5. **通用按钮反模式**
   - 具有用于不同用例的 8+ 可选参数的组件
   - 如此多的 props，使用它就像从头编写一样复杂

6. **过早抽象 - 三次法则**
   - 在第 1 次或第 2 次重复时创建的抽象（等待第 3 次！）
   - 参考：Martin Fowler - "容忍两次重复，在第三次时重构"

### KISS 违规模式

1. **冗长的实现**
   - 可以减少 >50% 的行
   - 重新实现标准库函数
   - 当简单字符串操作有效时使用复杂正则表达式

2. **抽象成瘾**
   - 超过 3 层继承/包装
   - 每层之间的接口

3. **聪明的代码**
   - 需要大量注释来解释
   - 不必要地使用生僻的语言功能
   - 应该是 5 清晰行的单行代码

4. **捕获-日志-退出反模式**
   - 捕获异常只是为了记录和退出
   - 用关于出了什么问题的猜测替换实际错误

   ```typescript
   // 糟糕：用猜测替换实际错误
   try {
     await createNewBranch({ branchName, cwd })
   } catch (error) {
     console.error('错误：不在 git 仓库中') // 可能错了！
     process.exit(1)
   }

   // 正确：让它自然抛出
   await createNewBranch({ branchName, cwd })
   ```

### 要检查的安全模式

即使在 YAGNI/KISS 审查中，也要标记关键安全问题：

1. **SQL 注入**
   - SQL 查询中的字符串连接
   - 缺少参数化查询

2. **身份验证/授权**
   - 硬编码的机密
   - 弱默认值：`SECRET = os.getenv('KEY', 'default')`
   - 没有过期的 JWT

3. **未验证的外部输入**
   - 直接使用而没有验证的 URL 参数
   - 在没有架构验证的情况下信任 API 响应数据

### 要检查的性能模式

标记明显的性能问题：

1. **N+1 查询问题**
   - 进行数据库调用的循环
   - 缺少预加载

2. **低效算法**
   - O(n²) 而 O(n) 或 O(n log n) 可以工作
   - 不必要的嵌套循环

## 步骤 3：执行分析

**检查 `--deep` 标志**：如果存在，使用具有 6 个顺序通道的多通道深度模式。否则，使用快速 YAGNI/KISS 模式。

**重要**：仅分析在此审查范围中实际更改的代码。
不要标记预先存在的问题。

## 步骤 3.5：自我审查通道

**在展示发现之前，验证每个问题：**

1. **证据检查：**
   - 我能提供支持此批评的链接/参考吗？
   - 我解释了为什么这很重要吗？

2. **严重性验证：**
   - 此评级是否准确（高/中/低）？
   - 此问题真的会导致问题吗？

3. **YAGNI 特定检查：**
   - 如果标记重复：这是第 3 次及以上出现吗？
   - 这可以稍后在我们有更多信息时重构吗？

**删除或降级任何未通过这些检查的问题。**

## 步骤 4：交互式审查流程

### 问题严重性前缀

使用这些前缀传达优先级：

| 前缀 | 含义 | 需要的操作 |
| ---- | ---- | ---------- |
| `issue:` | 错误、正确性问题 | 合并前必须修复 |
| `nit:` | 小改进、风格 | 可选、不阻塞 |
| `thought:` | 设计考虑 | 讨论、可以推迟 |
| `suggestion:` | 带有代码的具体改进 | 认真考虑 |

### 交互式演练

对于每个问题，展示：

```
═══════════════════════════════════════
问题 [当前] / [总计]
═══════════════════════════════════════

📁 文件：[文件名]
📍 行：[开始-结束]
🏷️  类型：[YAGNI | KISS | 两者]
🎯 严重性：[高 | 中 | 低]

当前代码：
[显示实际代码片段]

检测到的问题：[具体描述]

为何重要：[解释真正的成本/问题]

建议的简化：
[显示更简单的替代代码]

═══════════════════════════════════════

你想做什么？
1. ✅ 接受 - 添加到修复列表
2. ❌ 跳过 - 保留当前代码
3. 💬 讨论 - 标记供团队审查
4. 👀 上下文 - 查看更多周围的代码
5. ⏹️  停止 - 在此结束审查
```

## 步骤 5：核心审查规则

### 始终标记这些 YAGNI 问题：

1. **具有单个实现的接口**
2. **未使用的代码** - 具有零调用者的函数/方法
3. **投机性数据库字段** - 始终为 NULL 的列
4. **过早优化** - 在测量之前缓存

### 始终标记这些 KISS 违规：

1. **标准库重新实现**
2. **过度抽象层**
3. **配置优于约定** - 50 行代码的 100 行配置

### 不要标记这些：

1. **必要的复杂性** - 错误处理、安全措施
2. **领域复杂性** - 确实复杂的业务规则
3. **团队约定** - 商定的模式

## 步骤 6：最终摘要

```
📝 实用审查完成
═══════════════════════════════

审查统计：
• 已审查文件：[X]
• 已更改行：[Y]

发现的问题：[Y 总计]
• 关键（阻塞）：[计数]
• 高优先级：[计数]
• 中等：[计数]
• 低：[计数]

复杂性降低潜力：
• 可移除行：~[总计] (-X%)
• 不必要的抽象：[计数]

前 3 个快速获胜：
1. [最大影响、最容易更改]
2. [第二大影响]
3. [第三大影响]

建议：[带有推理的明确发布/不发布]

═══════════════════════════════
```

## 命令参数参考

- `--auto`：跳过交互式提示，使用默认值（未提交的更改）
- `--ci`：CI 模式 - 跳过所有提示，审查分支与基础
- `--deep`：启用 6 通道综合审查
- `--branch [name]`：审查特定分支
- `--base [branch]`：与此基础分支比较

示例：

- `/pragmatic-review` - 交互模式
- `/pragmatic-review --auto` - 自动审查当前更改
- `/pragmatic-review --ci` - GitHub Actions 的 CI 模式
- `/pragmatic-review --deep` - 综合 6 通道审查

## 核心原则

当有疑问时，请记住：

1. **YAGNI**：功能的成本是 4 倍：构建时间、维护成本、修复成本、机会成本
2. **KISS**：调试的难度是编写的两倍 - 如果你编写了最聪明的代码，根据定义，你就不够聪明来调试它
3. **三次法则**：容忍两次重复，第三次时重构
4. **实用主义**：今天发布可工作的软件，明天再完善

你是简洁的捍卫者。删除的每一行代码都是胜利。

## 参考

- Martin Fowler - YAGNI: https://martinfowler.com/bliki/Yagni.html
- KISS 原则: https://en.wikipedia.org/wiki/KISS_principle
- OWASP 前 10: https://owasp.org/www-project-top-ten/
- Addy Osmani - "避免大型拉取请求"
- Jeff Atwood - "Curly 定律：做一件事"
